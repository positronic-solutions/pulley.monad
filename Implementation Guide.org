#+title: The =pulley.monad= Implementation Guide
#+author: Nathan Davis

#+begin_comment
Copyright 2016-2017 Positronic Solutions, LLC.

This file is part of pulley.monad.

pulley.monad is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

pulley.monad is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with pulley.monad.  If not, see <http://www.gnu.org/licenses/>.
#+end_comment

# Have Org export all headlines (or at least to level 100) as headings
#+options: H:100

* Introduction
  This document describes the design and implementation of =pulley.monad=,
  a Clojure library for composition and execution of monadic computations.
  Unlike other monad libraries, =pulley.monad= encourages users
  to express computations in a single monad
  — a "generic" monad, which constructs a computation which can then
  be applied to any number of concrete monad implementations.
  The monad operators, ~return~ and ~bind~, are implemented in terms
  of this generic monad.

  In other words, the Generic monad allows the details
  of a computational effect to be deferred until runtime.
  This late binding provides for a great deal of flexibility
  in the runtime behavior of a computation.
  Different effects can be achieved with the same computation
  by varying the concrete implementation.

  This pattern is similar to polymorphic behavior available in other languages,
  such as Haskell's "type classes" and Scala's "implicits".
  Indeed, the implementation is similar
  to [[http://okmij.org/ftp/Computation/typeclass.html#dict][how one might implement such polymorphic constructs]] in these languages
  -- a map of concrete operations is passed as an implicit argument
  to polymorphic functions.
  The primary difference is that in Haskell,
  the map of operations is completely hidden from the programmer
  and is constructed automatically based on the static types involved.
  In =pulley.monad=, the programmer has complete control
  over the operations map, and can tailor it dynamically to suite their needs.

  Thus, =pulley.monad= can be seen as providing a sort of framework
  for expressing "interpretters" for generic operations.
  In this way, =pulley.monad= is similar to the way Free monads
  are used to write layered "interpretters".
  However, =pulley.monad= achieves this result
  without introducing an intermediate data structure to represent a computation
  — all generic computations are expressed using compiled functions.

  All library code in this document is placed
  in the ~com.positronic-solutions.pulley.monad~ namespace:

  #+name: pulley.monad::ns
  #+begin_src clojure
    (ns com.positronic-solutions.pulley.monad)
  #+end_src
* The Generic Monad
  The Generic monad expresses a computation as a type =G a= where:
  * =G= is the type of the Generic monad
  * =a= is the result type of the computation
  * =G a= denotes that type =G= is parameterized over some type =a=.

  The general idea is that =G a= represents a computation
  (i.e., a monadic value).
  However, the details of carrying out that computation is defered
  until a map of operations is provided.

  This suggests an implementation where =G a= has type =Mops → M a= where:
  * =Mops= is an object containing the set of operations
    for implementing the monad =M=.
  * =M= is the monad type implemented by =Mops=.
    The type =M= depends on the value of =Mops=
    (i.e. different valued =Mops= will yield different =M='s).
    However, in this document, we treat =M= as a single type
    for the sake of brevity.
  * =a= is the result type of the computation.

  =Mops= is some representation of the operators
  for implementing some particular monad type =M=.
  In =pulley.monad=, an =Mops= is represented via a Clojure map
  containing (at least) the following keys:
  * ~::return~ :: Defines =M='s ~return~ operator.
  * ~::bind~ :: Defines =M='s ~bind~ operator

  In Haskell's terms, we can view =Mops= as a reification of a typeclass
  — i.e., it contains the set of methods for a particular instance
  of the typeclass.
  Specifically, an =Mops= provides an implementation of the =Monad= typeclass.

  Here and elsewhere in this document, unless otherwise noted,
  relatively namespaced keywords
  (such as ~::return~ and ~::bind~) are namespaced relative
  to the ~com.positronic-solutions.pulley.monad~ namespace
  (i.e., ~::return~ is interpretted as
  ~:com.positronic-solutions.pulley.monad/return~, etc.)
  By using qualified keywords, we can allow users and other libraries
  to add arbitrary "extension methods" to an =Mops=
  without risk of naming conflicts
  (provided each participant chooses an appropriate, unique namespace
  for their keys).

  Because we allow for arbitrary extension methods to be added to the map,
  it may be useful for some implementations to have access
  to the method map.
  While =pulley.monad= does nothing to support this per se,
  it is possible to use [[https://github.com/positronic-solutions/pulley.objective][=pulley.objective=]] objects with =pulley.monad=.
  [[https://github.com/positronic-solutions/pulley.objective#persistentobject][Objective objects]] provide a map-like interface,
  but allow for dynamic calculations to be performed during lookup
  (via [[https://github.com/positronic-solutions/pulley.objective#properties][Objective properties]]).
  One application of this is [[https://github.com/positronic-solutions/pulley.objective#methods][Objective methods]],
  which provide a mechanism for implementing functions
  that have access to the instance object upon which it was invoked.
  The instance object is implicitly added to the front of the argument list
  when the method is inovoked.
  The operations implemented by =pulley.monad=
  maintain compatibility with Objective objects
  and Objective method invocations.
  Therefore, it's possible to use Objective objects in lieu of Clojure maps.

  So ~::return~ maps to a function of type =a → M a=
  (or an Objective method with effective type =Mops × a → M a=),
  and ~::bind~ to a function of type =M a × (a → M b) → M b=
  (or an Objective method with effective type =Mops × M a × (a → M b) → M b=).
  These are the types we would expect to see for a monad.

  Since the type of a generic computation =G a=
  is a function of type =Mops → M a=,
  in order to actually compute an =M a= from a =G a=
  we must extract the =M a= from that =G a= by supplying an appropriate =Mops=.
  We therefore define the ~run~ function,
  which takes a =G a= and an =Mops= and returns the corresponding =M a=.
  Since =G a= is =Mops → M a=,
  this is as simple as applying the given =G a= to the given =Mops=.

  #+name: run
  #+begin_src clojure
    (defn run
      "run :: Mops × Ga → M a

      Executes the given generic monadic value mv
      with the (concrete) monad given by m."
      ([m mv]
        (mv m)))
  #+end_src

  Here ~m~ is an =Mops= and ~mv~ is a =G a=.
  ~run~ returns an =M a=, where =M= is the monad type defined by =Mops=.
* Implementing the Generic Monad
  This section describes the implementation of ~return~ and ~bind~
  for the generic monad.
** ~return~
   For a monad =G=, ~return~ is defined to have type =a → G a=.
   As described earlier, =G a= is the type =Mops → M a=.
   Therefore, ~return~ must have type =a → (Mops → M a)=.
   Conveniently, the ~::return~ function in =Mops= has type =Mops × a -> M a=.
   So ~return~ is:

   #+name: return
   #+begin_src clojure
     (defn return
       "Wraps the given pure value given by a into the generic monad."
       ([v]
         (fn [m]
           ((m ::return) v))))
   #+end_src

   We use the form ~(m ::return)~ to lookup ~::return~ in ~m~,
   rather than ~(get m ::return)~ or ~(::return m)~,
   because the first form is currently the only way
   that Objective objects resolve [[https://github.com/positronic-solutions/pulley.objective#properties][properties]].
   If we used one of the other ways,
   we would not be compatible with Objective methods.
** ~bind~
   ~bind~ has type =G a × (a → G b) → G b=.
   Expanding =G= as above, we get
   =(Mops → M a) × (a → (Mops → M b)) → (Mops → M b)=.
   It is tempting to define ~bind~ as follows:

   #+begin_src clojure
     (defn bind [mv f]
       (fn [m]
         ((m ::bind) mv f)))
   #+end_src

   However, while ~bind~'s ~mv~ parameter has type =G a=,
   the equivalent parameter to ~m~'s ~::bind~ method
   has type =M a=.
   Since =G a= is =Mops → M a=, this is easy to rectify
   by applying ~mv~ to ~m~
   (alternatively, we could use ~(run m mv)~).

   Similarly, ~bind~'s ~f~ parameter has type =a → G a=,
   but ~m~'s ~::bind~ requires an =a → M a=.
   So we need some function ~f′~ that will first apply ~f~
   to the given =a= value,
   then convert the resulting =G a= into an =M a=.
   Once again, this is easily accomplished via function application.
   Thus, ~f′~ is:

   #+begin_src clojure
     (fn [v]
       (run m (f v)))
   #+end_src

   In this case, we use ~run~ instead of ~((f v) m)~ for ease of reading.
   It also makes explicit that we are "running" ~(f v)~ in ~m~.

   We can now implement ~bind~:

   #+name: bind
   #+begin_src clojure
     (defn bind
       "Binds the generic monadic value mv to the given function f.

       If mv has type 'G a' (where G is the parameterized type
       identifying the generic monad), then f must have the type:

         a → G b"
       ([mv f]
         (fn [m]
           (let [f' (fn [v]
                      (run m (f v)))]
             ((m ::bind) (mv m) f')))))
   #+end_src
* Generic Operations
  The generic monad passes around an operations map during its execution.
  While the purpose of this map is primarily
  to contain implementions of ~return~ and ~bind~ for a specific monad,
  it is also a convenient place to put other monad-specific operations.
  For example, a State monad might add operations
  for getting and setting the current state.

  Rather than relying on ad-hoc solutions
  to accessing the current operations map
  and incorporating operations stored in it into a computation,
  =pulley.monad= provides some operations that provide these services
  in a structured manner.
  This section describes those operations.
** Accessing Operation Maps
   Sometimes it's useful for a generic computation to gain access
   to the operations map.
   For example, a generic dispatch function would use the map
   to lookup the concrete implementation for the operation.

   It's trivial to gain such access in an ad-hoc fashion.
   For example:

   #+begin_src clojure
     (fn [ops]
       <do-something-with ops>)
   #+end_src

   Assuming ~<do-something-with ops>~ has type =M a=,
   this is a term in the Generic monad.
   However, this code depends on intimate knowledge
   of the representation of Generic terms.
   This is something we wish to encapsulate.

   Furthermore, the result is required to be an =M a=.
   But if ~<do-something-with ops>~ uses generic operations
   (whose results are of type =G a=),
   these results must be converted to an =M a=.
   This is inconvenient.
*** ~get-ops~
    To allow access to the operations map
    in a way that respects encapsulation of the Generic monad,
    we define ~get-ops~:

    #+name: get-ops
    #+begin_src clojure
      (defn get-ops
        "get-ops :: () → G Mops

        Returns the current operations map as a term in the Generic monad."
        ([]
          (fn [ops]
            ((ops ::return) ops))))
    #+end_src

    ~ops~ is a pure value that we wish to take into the Generic monad.
    ~get-ops~ returns a =G Mops= (which is =Mops → M Mops=).
    So we need to convert ~ops~ into a concrete monad term.
    We do this via the ~::return~ operation in ~ops~.

    To use the operations map in a computation,
    we simply ~bind~ the result of ~get-ops~:

    #+begin_src clojure
      (bind (get-ops)
            (comp return keys))
    #+end_src
**** Alternative Implementation
     We could define ~get-ops~ as follows:

     #+begin_src clojure
       (def get-ops (fn [ops]
                      ((ops ::return) ops)))
     #+end_src

     In this case, ~get-ops~ itself would be a Generic monad term
     (rather than a function returning a Generic monad term),
     and we could simply write:

     #+begin_src clojure
       (bind get-ops
             (comp return keys))
     #+end_src

     However, we use the former definition
     (requiring ~get-ops~ to be called in order to obtain a term)
     in order to make it clear that ~get-ops~ performs a computational effect
     (namely, obtaining the operations map of the commputation).
*** ~bind-ops~
    When we use ~get-ops~, it is almost inevitably to ~bind~ it.
    While we can ~bind~ the result of ~get-ops~ easily enough,
    ~bind-ops~ provides a convenient way to perform this
    in one abstract step.

    ~bind-ops~ takes a function ~f~,
    and returns a Generic computation that ~binds~ the current operations map
    with ~f~.  Its implementation is straight-forward:

    #+name: bind-ops
    #+begin_src clojure
      (defn bind-ops
        "bind-ops :: (Mops → G b) → G b

        Returns a generic computation that binds the runtime operations map with f"
        ([f]
          (bind (get-ops)
                f)))
    #+end_src

    Now we can write:

    #+begin_src clojure
      (bind-ops (comp return keys))
    #+end_src
*** ~let-ops~
    ~let-ops~ provides some syntactic sugar around ~bind-ops~,
    allowing users to obtain an operations map via a ~let~-like form.

    #+name: let-ops
    #+begin_src clojure
      (defmacro let-ops
        "Macro version of bind-ops.

        Constructs a Generic computation in which the operations map
        is bound to name."
        ([[name :as binding] & body]
          (if (= 1 (count binding))
            `(bind-ops (fn [~name]
                         (>> ~@body)))
            (throw (new IllegalArgumentException
                        "let-ops binding must contain exactly one form")))))
    #+end_src

    Although the ~binding~ portion of ~let-ops~ consists entirely
    of a single name,
    it must still be wrapped in a vector.
    This is to maintain visual similarity with Clojure's ~let~.
    (Actually, we do not enforce a vector here.
    Anything that works with the destructuring pattern will do.
    But it would be idiomatic to use a vector.
    We do enforce the constraint of exactly one element.)

    With ~let-ops~, we can write:

    #+begin_src clojure
      (let-ops [ops]
        (return (keys ops)))
    #+end_src
** Dispatch Functions
   Now that we have operations to extract the operations map at run-time,
   we can define functions that dispatch functions in the operations map.

   For example:

   #+begin_src clojure
     (defn foo [x y z]
       (let-ops [ops]
         (let [f (ops ::foo)]
           (f x y z))))
   #+end_src

   Here, ~foo~ is a function which, when called,
   returns a term in the Generic monad.
   When this term is ~run~, the following happens:

   * The operations map is bound to ~ops~
   * The function associated with ~::foo~ in ~ops~ (~f~) is looked-up
   * ~f~ is applied to the arguments provided
     in the original call to ~foo~.

   This effectively turns ~foo~ into a "generic operation"
   — an operation whose implementation is deferred.
   It should be noted that the value returned by ~f~
   must be a Generic monad term (i.e., a =G a=).

   While this does not break encapsulation, it is a useful pattern.
   So we'll define some operations to avoid unecessary repetition.
*** ~op-fn*~
    ~op-fn*~ abstracts the fundamentals of generating a dispatch function.
    It takes one or two arguments.
    The first argument specifies the key used
    to lookup the implementation function in the operations map.
    The second argument (if provided) is a function
    that provides the default behavior to be used
    if no associated function is found in the operations map.
    If no default is given, the default behavior is to throw an exception.

    #+name: op-fn*
    #+begin_src clojure
      (defn op-fn*
        ([key]
          (op-fn* key (fn [& args]
                        (throw (new IllegalStateException
                                    (str "No implementation found for " key))))))
        ([key default]
          (fn [& args]
            (let-ops [ops]
                     (let [f (if (contains? ops key)
                               (ops key)
                               default)]
                       (apply f args))))))
    #+end_src

    (We use ~if~ and ~contains~, rather than ~(get ops key default)~,
    because, as of this writing, using ~get~ would break compatibility
    with Objective methods.
    This should be revisited in the future.)
*** ~op-fn~
    ~op-fn~ provides a macro version of ~op-fn*~.
    In addition to the key,
    it takes an (optional) default action
    as a function definition (as with ~fn~),
    rather than an actual function.
    ~op-fn~ is expressed in terms of ~op-fn*~:

    #+name: op-fn
    #+begin_src clojure
      (defmacro op-fn
        ([key]
          `(op-fn* ~key))
        ([key & default]
          `(op-fn* ~key
                   (fn ~@default))))
    #+end_src

    We could make the default action required here,
    since one could just as well use ~op-fn*~ in that case
    (there really isn't any "sugar" provided
    by ~op-fn~ if there is no default given).
    However, there really isn't any good reason
    to impose such a restriction.
*** ~defop~
    ~defop~ provides a convenient way to define a top-level dispatch function.
    ~defop~ expects its arguments to take the form
    ~[name kw? docstring? & default]~, where:

    * ~name~ is a symbol
    * ~kw?~ is an optional keyword
    * ~docstring?~ is an optional string to be used as ~name~'s docstring.
    * ~default~ represents an optional default action
      (as would be used with ~op-fn~).

    The general form we wish to expand to is this:

    #+begin_src clojure
      (def ~name
        ~docstring?
        (op-fn ~kw? ~@default))
    #+end_src

    Because of all the optional arguments,
    we need to do some amount of parsing of the arguments.
    Some of this can be handled by defining multiple arities.

    The first arity takes the form ~[name]~:

    #+name: defop/1
    #+begin_src clojure
      ([name]
        `(defop ~name ~(symbol->keyword name)))
    #+end_src

    In this case, only the ~name~ is given.
    But we need a key to pass to ~op-fn~.
    We could use the symbol given by ~name~,
    but this has a couple problems:

    * The symbol associated with ~name~ is not qualified.
      So at minimum, we would need to quality ~name~
      with the current namespace (~*ns*~)
      or risk a large likely-hood of conflicting keys.
    * It is anticipated that (qualified) keywords
      will be the most commonly used key type for operation maps
      (as least it is consistent with our use so far within =pulley.monad=).
      ~defop~ should certainly promote this,
      rather than work against it.

    For these reasons, when ~defop~ is given only a name,
    it  generates a keyword based on that name
    and expands to another ~defop~ form
    that specifies both the name and the keyword.
    For this purpose, we assume the existance
    of a function ~symbol->keyword~ which,
    given a symbol, returns a keyword thas has the same name
    of that symbol and is namespaced to the current namespace (~*ns*~).

    The second arity takes the form ~[name kw?]~.
    ~kw?~ might or might not be a keyword.
    If it is a keyword, then it is used as the lookup key.
    If not, we generate a keyword from ~name~ (via ~symbol->keyword~)
    and expand to another ~defop~ form:

    #+name: defop/2
    #+begin_src clojure
      ([name kw?]
        (if (not (keyword? kw?))
          ;; then (generate keyword from name and recurse)
          `(defop ~name ~(symbol->keyword name)
             ~kw?)
          ;; else (use given keyword)
          `(def ~name
             (op-fn ~kw?))))
    #+end_src

    The negative form ~(not (keyword? kw?))~ is used for the check,
    simply because it is consistent with the condition used
    in the ~cond~ expression for the variadic form of ~defop~.

    The third and final arity is variadic
    and takes the form ~[name kw? docstring? & default]~.
    Similar to the arity-2 form,
    ~kw?~ might or might not actually be a keyword
    and ~docstring?~ might or might not actually be a docstring.
    This means we need to handle the following conditions:

    * ~kw?~ is not a keyword:
      * use ~symbol->keyword~ to generate an appropriate keyword
      * expand to another ~defop~ form
        with the generated keyword in that position
    * ~docstring?~ is not a string (but ~kw?~ is a keyword):
      * expand to a ~def~ form that includes ~docstring?~
        as part of the default action
        in the constituent ~op-fn~ expression.
    * otherwise (~kw?~ is a keyword and ~docstring?~ is a string):
      * expand to a ~def~ form that includes ~docstring~
        in the docstring location of the ~def~ form

    #+name: defop/3+
    #+begin_src clojure
      ([name kw? docstring? & default]
        (cond
          (not (keyword? kw?))       `(defop ~name ~(symbol->keyword name)
                                        ~kw?
                                        ~docstring?
                                        ~@default)
          (not (string? docstring?)) `(def ~name
                                        (op-fn ~kw? ~docstring? ~@default))
          :else                      `(def ~name
                                        ~docstring?
                                        (op-fn ~kw? ~@default))))
    #+end_src

    So far, we have been assuming the existence of ~symbol->keyword~
    without giving a definition for it.
    The following is its definition:

    #+name: defop/symbol->keyword
    #+begin_src clojure
      (fn [sym]
        (keyword (name (ns-name *ns*))
                 (name sym)))
    #+end_src

    Now, we can put these pieces together
    into a complete definition for ~defop~:

    #+name: defop
    #+begin_src clojure :noweb yes
      (let [symbol->keyword
                <<defop/symbol->keyword>>]
        (defmacro defop
          <<defop/1>>
          <<defop/2>>
          <<defop/3+>>))
    #+end_src
* Concrete Monad Implementations
  This section describes how concrete monads are implemented
  in terms of the Generic monad.

  To review, =G a= represents the type of a generic computation
  whose result type is a.
  In the present implementation, values of type =G a=
  are represented by the type =Mops → M a=,
  where =M= is a concrete monad,
  whose type is fixed by =Mops=.
  So a =G a= is a function which, when given a concrete monad implementation,
  computes a computation in that concrete monad.
  While we could call this function directly,
  it is preferrable to do so indirectly via ~run~.

  So far, we have been focusing on composing =G a='s.
  We will now shift our focus to the nature of =Mops=
  and the construction of =M a='s.
** Identity Monad
   The simplest monad is the "Identity" (or "Let") monad.
   Basically, the Identity monad takes a pure value into a computation
   as itself.

   In other words, ~return~ in the Identity monad is just Clojure's ~identity~.

   ~bind~ is almost as simple — all we need to do is apply the given function
   to the given value:

   #+name: identity-m/bind
   #+begin_src clojure
     (fn [mv f] (f mv))
   #+end_src

   We now have all we need to construct an =Mops= map:

   #+name: identity-m
   #+begin_src clojure :noweb yes
     (def identity-m
       {::return identity
        ::bind   <<identity-m/bind>>})
   #+end_src

   This is nothing but the classic construction of the Identity monad.

   Now consider the following generic terms:

   #+name: test/terms
   #+begin_src clojure
     (def v1 (return 2))
     (def v2 (return 3))

     (def t1 (bind v1
                   (fn [x]
                     (bind v2
                           (fn [y]
                             (return (+ x y)))))))
   #+end_src

   ~v1~ and ~v2~ return the values 2 and 3 respectively.
   ~t1~ extracts the values from ~v1~ and ~v2~ and returns their sum.

   These terms are in the Generic monad.
   However, we can convert them to terms in the Identity monad
   by calling ~run~ with ~identity-m~:

   #+begin_src clojure
     (run identity-m t1)
   #+end_src

   This returns the value ~5~.
** List Monad
   Likewise, we can implement the standard List monad:

   #+name: list-m
   #+begin_src clojure
     (def list-m
       {::return (fn [v]
                   (list v))
        ::bind   (fn [mv f]
                   (mapcat f mv))})
   #+end_src

   ~(run list-m t1)~ returns ~(5)~
   (that is, a singleton list containing ~5~).
** State Monad
   Finally, we can implement the State monad:

   #+name: state-m
   #+begin_src clojure :noweb yes
     (def state-m
       {::return    (fn [v]
                      (fn [s]
                        [s v]))
        ::bind      (fn [mv0 f]
                      (fn [s0]
                        (let [[s1 v1] (mv0 s0)
                              mv1 (f v1)]
                          (mv1 s1))))
        <<state-m/get-state>>
        <<state-m/set-state>>})
   #+end_src

   The State monad type is a function that accepts an initial state
   and returns a vector containing the new state and a value.
   So ~(run state-m t1)~ returns a function.
   If we pass that function an initial state,
   we obtain a ~[final-state value]~ pair.
   For example:

   #+begin_src clojure
     ((run state-m t1) {})
   #+end_src

   Returns ~[{} 5]~.
*** ~get-state~
    The purpose of the State monad is to thread some piece of state
    through a computation.
    But without the ability to access and manipulate this state,
    there's no point of it even existing.
    The ~get-state~ operation allows us to access the current state
    of a State monad computation.

    We could implement ~get-state~ as follows:

    #+name: get-state/params
    #+begin_src clojure :exports none
      []
    #+end_src

    #+name: get-state/body
    #+begin_src clojure :exports none
      (lift|concrete->generic (fn [state]
                                [state state]))
    #+end_src

    #+begin_src clojure :noweb yes
      (defn get-state <<get-state/params>>
        <<get-state/body>>)
    #+end_src

    However, this locks us into a particular implementation
    of the State monad.
    There's no reason we couldn't define another State monad
    that uses a different representation.
    But we would be unable to use this ~get-state~ function
    with that implementation — the details of the implementation leak through!

    It would be better if we could define ~get-state~
    in such a way that it could be used with any monad
    that provides a ~get-state~ operation.
    This is what generic operations give us.
    So, we define ~get-state~ as a generic operation:

    #+name: get-state
    #+begin_src clojure
      (defop get-state)
    #+end_src

    Then we move the implementation to the ~state-m~ operations map:

    #+name: state-m/get-state
    #+begin_src clojure :noweb yes
      ::get-state (fn <<get-state/params>>
                    <<get-state/body>>)
    #+end_src
*** ~set-state~
    Where ~get-state~ allows us to get the current state of a computation,
    ~set-state~ allows us to change the current state.
    ~set-state~ can be implemented as follows:

    #+name: set-state/params
    #+begin_src clojure :exports none
      [new-state]
    #+end_src

    #+name: state-m/set-state/body
    #+begin_src clojure :exports none
      (lift|concrete->generic (fn [old-state]
                                [new-state new-state]))
    #+end_src

    #+begin_src clojure :noweb yes
      (defn set-state <<set-state/params>>
        <<state-m/set-state/body>>)
    #+end_src

    However, we abstract the operation as a generic operation:

    #+name: set-state
    #+begin_src clojure
      (defop set-state)
    #+end_src

    and add the implementation to the operations map:

    #+name: state-m/set-state
    #+begin_src clojure :noweb yes
      ::set-state (fn <<set-state/params>>
                    <<state-m/set-state/body>>)
    #+end_src
* Auxilliary Functions and Macros
** ~lift|concrete->generic~
   Sometimes, it's useful to explicitly provide an =M a=.
   For example, with ~list-m~ it would be nice to be able to write:

   #+begin_src clojure
     (run list-m
       (bind (range 2)
             (fn [x]
               (bind ["foo" "bar"]
                     (fn [y]
                       (return [x y]))))))
   #+end_src

   The intent here is to generate the cartisian product =[0 1] × ["foo" "bar]=:

   #+begin_src clojure
     ([0 "foo"]
      [0 "bar"]
      [1 "foo"]
      [1 "bar"])
   #+end_src

   However, ~(range 2)~ has ~list-m~'s =M a= type,
   but ~bind~ requires a =G a=, not an =M a=, here.
   So we need to somehow convert an =M a= into a =G a=.

   One might attempt to do this via ~return~
   (e.g., ~(return (range 2))~).
   However, since ~return~ has type =a → G a=
   (rather than =M a → G a=),
   ~return~ will turn an =M a=
   into a =G (M a)=, instead of the desired =G a=.

   Since =G a= is =Mops → M a=,
   it follows that we can convert an =M a= to a =G a=
   by wrapping the =M a= in a function.
   For example,

   #+begin_src clojure
     (fn [m]
       (range 2))
   #+end_src

   is a =G Long= value which, when ~run~, returns an =M a= value
   (where =M= is ~list-m~'s monad type, namely ~[]~ or ~clojure.lang.ISeq~).

   However, this is likely to be a fairly common pattern.
   Moreover, the particulars of the Generic monad implementation leak through.
   If we wish to change the way we implement the Generic monad in the future,
   it will be necessary to change all instances of this pattern
   to reflect the new implementation.

   So, in order to better encapsulate the Generic monad and reduce boiler-plate,
   we provide the ~lift|concrete->generic~ function.
   The ~lift|concrete->generic~ function takes a monadic value
   and wraps ("lifts") it
   into the Generic monad – i.e., it converts an =M a= into a =G a=.

   #+name: value
   #+begin_src clojure
     (defn lift|concrete->generic
       "Lifts the (concrete) monadic value mv into the generic monad."
       ([mv]
         (fn [m]
           mv)))
   #+end_src

   We can now write:

   #+begin_src clojure
     (run list-m
       (bind (lift|concrete->generic (range 2))
             (fn [x]
               (bind ["foo" "bar"]
                     (fn [y]
                       (return [x y]))))))
   #+end_src
** ~when-run~ / ~when-run*~
   Since Clojure uses eager evaluation,
   sometimes it's necessary to delay execution of an expression
   until the monadic expression it is attached to is logically ~run~.
   The ~when-run~ macro constructs a monadic value which,
   when ~run~, evaluates the given expression.
   The result must be a monadic value (which is also ~run~).

   #+name: when-run
   #+begin_src clojure
     (defmacro when-run
       "Constructs a monadic expression which, when run,
       evaluates expr and runs the result.

       Note:  when-run should not be used if expr produces side-effects!
              In that case, use io instead."
       ([expr]
         `(when-run* (fn []
                       ~expr))))
   #+end_src

   We choose to implement ~when-run~ in terms
   of its functional variant, ~when-run*~.
   An alternative would be to implement ~when-run~ directly.
   However, implementation in terms of ~when-run*~ has one major benefit.
   By decoupling the macro (~when-run~) from the implementation (~when-run*~),
   we are ensured of correct operation
   — even if a ~when-run~ expression happens
   to be expanded with a version of =pulley.monad=
   that uses a completely different representation for Generic Monad values.

   ~when-run*~ is implemented as follows:

   #+name: when-run*
   #+begin_src clojure
     (defn when-run*
       "Functional variant of when-run macro.
       Returns a monadic value which, when run,
       invokes thunk and runs the result.

       Note:  when-run* should not be used if thunk produces side-effects!
              In that case, use io* instead."
       ([thunk]
         (fn [ops]
           (run ops (thunk)))))
   #+end_src
** ~>>=~
   Our implementation of ~bind~ takes exactly two arguments,
   just like Haskell's bind operator, ~>>=~.
   Since Clojure allows variadic functions,
   it would seem natural to provide a variadic version of ~bind~,
   which we will call ~>>=~.

   #+name: >>=
   #+begin_src clojure
     (defn >>=
       "Monad sequencing operator, with value passing.

       Basically, this is a variadic version of bind."
       ([mv]
         mv)
       ([mv f]
         (bind mv f))
       ([mv f0 & fs]
         (bind mv
               (fn [v]
                 (apply >>= (f0 v) fs)))))
   #+end_src

   We can now use ~>>=~ to "thread" computations
   (similar to Clojure's threading macros, e.g. ~->~):

   #+begin_src clojure
     (run identity-m
       (>>= (return 5)
            (comp return inc)
            (fn [x]
              (return (* 2 x)))))
   #+end_src

   This example starts with the value ~5~,
   increments it, then doubles the incremented value.
   Note the use of ~return~ to wrap the "pure" values
   returned by ~inc~ and ~*~.
** ~>>~
   Sometimes the purpose of executing a computation
   is solely for producing side-effects.
   In these cases, we don't care what the resulting value is —
   we just need to execute the computation.

   Haskell provides a ~>>~ function for this.
   It takes two monadic values and returns a new monadic value which,
   when executed, first executes the computation embodied
   in the first monadic value,
   then executes the computation embodied in the second monadic value.
   The result of the first computation is discarded,
   while the result of the second may be bound (via ~bind~)
   to another computation.

   Our ~>>~ function is similar to Haskell's ~>>~,
   but our ~>>~ is variadic.
   All values are discarded, except the one produced by the last computation.

   #+name: >>_
   #+begin_src clojure
     (defn >>
       "Monad sequencing operator.

       This is essentially a non-value-passing version of >>=:
       ,* It accepts monadic values, not functions
       ,* The monadic values are computed in order
       ,* The value of all but the last computation is discarded
       ,* The value of the last computation is the value of the entire >> expression"
       ([mv]
         mv)
       ([mv0 & mvs]
         (bind mv0
               (fn [v0]
                 (apply >> mvs)))))
   #+end_src
** ~m-let~
   While monads provide a wonderful framework for composing computations,
   the functional notation for /writing/ such descriptions
   can quickly lead to degenerate levels of nesting.

   For example, here's a monadic function that composes a computation
   to calculate the euclidean distance between two points:

   #+begin_src clojure
     (defn distance [mp1 mp2]
       (let [sqrt (fn [x]
                    (Math/sqrt x))
             square (fn [x]
                      (* x x))]
         (bind mp1
               (fn [p1]
                 (bind mp2
                       (fn [p2]
                         (return (->> (map - p1 p2)
                                      (map square)
                                      (reduce +)
                                      (sqrt)))))))))
   #+end_src

   Even in this simple example, we can start to see a definite "lean"
   to the code.
   It might seem like we could combine both ~bind~'s
   into a single call to ~>>=~.
   However, we need to use the values extracted from both ~mp1~ and ~mp2~
   in the computation of the final result.
   So this nesting really is necessary.

   In cases like this, a little syntactic sugar can go a long way.
   For example, the use of ~->>~ in the above example obviates the need
   for nesting within that expression — ~->>~ hides the nesting from us.
   For monads, Haskell provides "~do~-notation",
   which hides the nesting of ~>>=~ (~bind~) expressions.
   For example, we might express the above example in Haskell as follows:

   #+begin_src haskell
     distance mp1 mp2 = do p1 <- mp1
                           p2 <- mp2
                           return (sqrt squareDist)
                             where diff = zipWith - p1 p2
                                   squareDiff = map (^2) diff
                                   squareDist = foldl (+) squareDiff
   #+end_src

   This avoids nesting, while still letting us express the notion
   of binding the result of ~mp1~ to the name ~p1~,
   the result of ~mp2~ to the name ~p2~,
   then computing a final result from the values of ~p1~ and ~p2~.

   In a lot of cases (though not in every case),
   there will be some number of "binding expressions"
   followed by a single result expression.
   This is reminiscent of Clojure's ~let~ form
   — the main difference is that ~do~ binds variables
   to the result of executing a monadic value,
   rather than the direct result of an expression.

   In other words, we can capture the essence of Haskell's ~do~-notation
   by introducing a monadic version of ~let~.
   With such a macro, which we'll call ~m-let~,
   we can now write the example above as:

   #+begin_src clojure
     (defn distance [mp1 mp2]
       (let [sqrt (fn [x]
                    (Math/sqrt x))
             square (fn [x]
                      (* x x))]
         (m-let [p1 mp1
                 p2 mp2]
                (return (->> (map - p1 p2)
                             (map square)
                             (reduce +)
                             (sqrt))))))
   #+end_src

   We can define ~m-let~ as:

   #+name: m-let
   #+begin_src clojure
     (defmacro m-let
       "[bindings body]

       bindings -> [name expr & bindings]

       Binds each name in bindings to the corresponding monadic expression,
       then runs the monadic expressions given in the body."
       {:style/indent 1}
       ([bindings & body]
         (if (empty? bindings)
           `(>> ~@body)
           (let [[name expr & bindings'] bindings]
             `(bind ~expr (fn [~name]
                            (m-let [~@bindings']
                              ~@body)))))))
   #+end_src

   The implementation is straight-forward:
   * If there are no bindings, transform the ~body~.
     The ~body~ is a sequence of monadic expressions,
     so we just wrap them with ~>>~.
   * If there are bindings, transform the first binding:
     * Extract the variable name (~name~)
       and associated monadic expression (~expr~).
       (These are, respectively, the first two elements in ~bindings~.)
     * ~bind~ ~expr~ to ~name~.
       We do this via a function of a single parameter,
       whose name is given by ~name~.
       The body of this function expands to an ~m-let~ expression
       of the rest of the bindings (~bindings′~).

   As noted above, the ~body~ expressions are wrapped in ~>>~.
   So while all the ~body~ expressions are executed,
   the result of all but the last expression will be discarded.
   This is in line with the semantics of Clojure's ~let~.

   It's also worth emphasizing that all ~body~ expressions
   are /monadic/ expressions.
   That is, they must have type =G a=, rather than =a=.
   This is contrary to [[https://github.com/clojure/algo.monads][=algo.monad=]]'s ~domonad~ macro
   which wraps the body expression in an implicit ~return~.
   While this may seem convenient,
   it promotes a pattern where we bind a value to a variable,
   only to immediately (implicitly) wrap it in ~return~.
   So, in a sense, ~m-let~ would not be conducive
   to "proper tail recursion" if it wrapped the body with ~return~.
   On the other hand,
   it is a trival matter to explicitly wrap these expressions with ~return~
   when necessary.
** ~m-do~
*** Motivation
    While ~m-let~ covers a significant portion
    of the use-cases for Haskell's ~do~-notation,
    it does not cover them all.
    For instance, consider the following Haskell code:

    #+begin_src haskell
      do x <- getLine
         putStrLn $ "You entered: " ++ x
         y <- getLine
         putStrLn $ "You entered: " ++ y
         return $ x ++ y
    #+end_src

    This can be expressed using ~m-let~ as:

    #+begin_src clojure
      (m-let [x (m-read-line)
              _ (m-println "You entered: " x)
              y (m-read-line)
              _ (m-println "You entered: " y)]
        (return (str x y)))
    #+end_src

    Even in this example, we can see ~m-let~ start to break down
    — we need to introduce bogus variables (~_~) to keep the expression "flat".
    This is not unreasonable, but it is a bit "chatty"
    and can obfuscate side-effecting expressions.

    Now consider:

    #+begin_src haskell
      do x <- getLine
         let x' = "First line: " ++ x
         putStrLn x'
         y <- getLine
         let y' = "Second line: ++ y"
         putStrLn y'
         return [x', y']
    #+end_src

    With ~m-let~, the best we can do is:

    #+begin_src clojure
      (m-let [x (m-read-line)]
        (let [x' (str "First line: " x)]
          (>> (m-println x')
              (m-let [y (m-read-line)]
                (let [y' (str "Second line: " y)]
                  (>> (m-println y')
                      (return [x' y']))))))))
    #+end_src

    ~m-let~ breaks down entirely in the face of "pure" bindings.
    There's no way (with ~m-let~) to make the expression any flatter.

    (Actually, we could wrap pure expressions with ~return~:

    #+begin_src clojure
      (m-let [x  (m-read-line)
              x' (return (str "First line: " x))
              _  (m-println x')
              y  (m-read-line)
              y' (return (str "Second line: " y))
              _  (m-println y')]
        (return [x' y']))
    #+end_src

    If bogus variables are contrived, this is all the more so.
    But more importantly, the distinction between pure and monadic expressions
    is obfuscated.)

    What we would like to write is something like this:

    #+begin_src clojure
      (m-do :bind x  (m-read-line)
            :let  x' (str "First line: " x)
            (m-println x')
            :bind y  (m-read-line)
            :let  y' (str "Second line: " y)
            (m-println y')
            (return [x' y']))
    #+end_src

    This form has the following advantages:

    * The expression is flat
    * Side-effects are not obfuscated by bogus variables
    * Pure expressions are not obfuscated by wrapping them with ~return~
*** Design
    ~m-do~ takes one or more expressions.
    These expressions are expected to be regular Clojure expressions
    that evaluate to monadic values, except that:

    * Expressions of the form ~:let <x> <value>~
      are interpretted as a "pure let"
      (equivalent to ~let <x> = <value>~ in Haskell).
    * Expressions of the form ~:bind <x> <value>~
      are interpretted as a "monadic let"
      (equivalent to ~<x> <- <value>~ in Haskell).

    Valid ~m-do~ forms are summarized by the following grammar:

    #+begin_comment
    The following is implemented as a code-block
    (rather than an example)
    so that it can be inserted as a no-web reference
    into m-do's docstring.
    #+end_comment

    #+name: m-do/doc/grammar
    #+begin_src text
             <m-do-expr> -> (m-do <expr>* <monadic-expr>)
                  <expr> -> <let-expr> | <monadic-expr>
              <let-expr> -> <pure-let-expr> | <monadic-let-expr>
         <pure-let-expr> -> :let <symbol> <pure-expr>
      <monadic-let-expr> -> :bind <symbol> <monadic-expr>
    #+end_src

    where
    * ~<symbol>~ is any Clojure symbol (or destructuring expression)
      that can vailidly be used
      as a formal function parameter / variable in a ~let~ form.
    * ~<pure-expr>~ is any Clojure expression that evaluates to a "pure" value.
    * ~<monadic-expr>~ is any Clojure expression that evaluates
      to a "monadic" value.

    We require the final expression given to ~m-do~ to be a ~<monadic-expr>~.
    Alternatives would be to return the final bound value or ~(return nil)~
    in the event the final expression is a ~<let-expr>~.
    However, unlike a ~let~ expression,
    there is no inherent delineation between the "bindings" and "body" portions
    of the form.
    Furthermore, binding a variable that is never used
    is likely to be a mistake.
    So we take the conservative approach and reject such expressions.
**** Alternative Design (~<x> <- <value>~)
     Rather than specifying monadic bindings via ~:bind <x> <value>~,
     we could alternatively specify them via ~<x> <- <value>~.
     The latter has the advantage of being similar to Haskell's syntax,
     which is very clean.

     However, there are some disadvantages to this approach:

     * It departs from Clojure forms such as ~for~
       which provide a "precedence" of using keywords (e.g., ~:when~, ~:let~)
       to denote "special" expressions.
     * It is more difficult to parse.
     * On their own, ~<x>~, ~<-~, and ~<value>~ are all Clojure expressions
       which could conceivable evaluate to a monadic value.
       In particular, though unlikely, ~<-~ could be bound
       to a monadic value.
       So in a pathological sense, ~<x> <- <value>~ is ambigous.

     For these reasons, we do not implement this approach
     in the current version.
     This could be revisited in the future.
*** Implementation
    Implementation of ~m-do~ is split amongst two arities.

    The first is arity-1.
    Its single parameter must be a monadic expression.
    While there is little we can do to enforce this constraint in general,
    we do note that Clojure keywords are not valid Generic monad values.
    Since keywords play a major role in ~m-do~'s grammar,
    we therefore reject keywords in this position.
    In all other cases, the macro simply expands to the given expression.

    #+name: m-do/1
    #+begin_src clojure
      ([expr]
       (if (keyword? expr)
         (throw (new IllegalStateException
                     (str "Malformed m-do expression: " expr)))
         expr))
    #+end_src

    The second arity is variadic and is recursive.
    If the first parameter is a keyword,
    we also need to parse it as a let expression
    (or throw an exception if it is not well-formed).
    So it is quite a bit more complex.

    As far as parsing goes, we define a few local functions:

    * ~check-binding~ verifies that the head parameters
      constitute a well-formed let expression.
      If so, the given ~success~ continuation is called
      with original parameters.
      If the expression is determined to be malformed,
      the given ~fail~ continuation is called.
      Verification consists of simply checking there are enough aruments
      to complete the initial ~:let~ or ~:bind~ expression
      and have at least one additional expression "left over"
      (additional checking, in particular of the variable binding ~<x>~,
      will be performed later by the Clojure compiler
      when it encounters the generated ~let~ or ~fn~ form).
    * ~binding-failure~ is the sole ~fail~ continuation function used
      in conjunction with ~check-binding~.
      It simply takes the given message and throws an exception.
      Since it /is/ currently the only ~fail~ continuation used,
      we could reference this function directly in ~check-binding~.
      But parameterization makes it slightly easier
      to use different ~fail~ continuations
      if it becomes necessary to do so in the future.
    * ~pure-let~ handles transformation of a ~:let~ expression.
      It is passed as the ~success~ continuation to ~check-binding~
      when parsing a ~:let~ expression.
    * Similarly, ~monadic-let~ handles transformation of a ~:bind~ expression.
      It is passed as the ~success~ continuation to ~check-binding~
      when parsing a ~:bind~ expression.

    If the first parameter is not a keyword,
    then it is interpretted as a monadic expression
    and sequenced (via ~>>~) before the remaining ~m-do~ expressions.

    The complete definition of ~m-do~ is:

    #+name: m-do
    #+begin_src clojure :noweb yes
      (defmacro m-do
        "Provides syntactic sugar for monadic expressions
        in the spirit of Haskell's do-notation.

        Valid m-do expressions can be summarized by the following grammar:

          <<m-do/doc/grammar>>

        where
        ,* <symbol> is any Clojure symbol (or destructuring exprssion)
                   that can validly be used as a binding in a let form.
        ,* <pure-expr> is any Clojure expression that evaluates
                      to a \"pure\" value.
        ,* <monadic-expr> is any Clojure expression that evalues
                         to a \"monadic\" value.

        When an expression of the form :let <x> <value> is encountered,
        the remaining expressions in the m-do form are evaluated
        with <x> bound to the value produced by evaluating <value>.

        When an expression of the form :bind <x> <value> is encountered,
        the remaining expressions in the m-do form are evaluated
        with <x> bound to the value yielded by running the monadic computation
        described by <value>."
        <<m-do/1>>
        ([expr & exprs]
          (let [check-binding (fn
                                ([success fail kw]
                                  (fail (str "Malformed m-do expression: " kw)))
                                ([success fail kw name]
                                  (fail (str "Malformed m-do epxression: " kw " " name)))
                                ([success fail kw name expr]
                                  (fail (str kw " expression is not allowed as last expression in m-do")))
                                ([success fail kw name expr & exprs]
                                  (apply success kw name expr exprs)))
                binding-failure (fn [msg]
                                  (throw (new IllegalStateException msg)))
                pure-let (fn [kw name expr & exprs]
                           `(let [~name ~expr]
                              (m-do ~@exprs)))
                monadic-let (fn [kw name expr & exprs]
                              `(bind ~expr
                                     (fn [~name]
                                       (m-do ~@exprs))))]
            (if (keyword? expr)
              ;; then (dispatch according to keyword)
              (case expr
                :let  (apply check-binding pure-let binding-failure expr exprs)
                :bind (apply check-binding monadic-let binding-failure expr exprs)
                ;; else (throw exception)
                (throw (new IllegalStateException
                            (str "Unrecognized keyword parsing m-do expression: " expr))))
              ;; else (handle monadic expression)
              `(>> ~expr
                   (m-do ~@exprs))))))
    #+end_src
* Tests
  This section describes some of the tests for =pulley.monad=.
  There are other tests that are not included in this document.
  You can find these under the [[file:test][=test=]] directory.

  This section describes the generative testing technique
  that is used to test satisfaction of the monad laws.
  This code uses =test.check=.
  Because =test.check= requires Clojure version 1.7 or greater,
  these tests are only enabled within the =check= Leiningen profile.

  All code in this section is located
  in the ~com.positronic-solutions.pulley.monad.test.monad-laws~ namespace:

  #+name: test/monad-laws/ns
  #+begin_src clojure
    (ns com.positronic-solutions.pulley.monad.test.monad-laws
      (:require [com.positronic-solutions.pulley.monad :as m]
                [clojure.test.check.clojure-test :refer [defspec]]
                [clojure.test.check.generators :as gen]
                [clojure.test.check.properties :as prop]))
  #+end_src
** Utilities
   The first order of business is to define some utility functions.
   =pulley.monad= currently supplies neither a ~join~
   nor Kleisli composition (~>=>~) function.
   Since these functions are useful for generating computations,
   we define them here.

   Note that it is expected that =pulley.monad= will supply these functions
   at some point in the future.
   When this happens, these functions should be removed
   in favor of the library functions.
*** ~join~
    The ~join~ function takes a =G (G a)= value
    and converts it to a =G a= value.
    That is, ~join~ removes one layer of (generic) monadic wrapping.
    This is easily accomplished
    by binding the supplied monadic (=G (G a)=) value
    with the ~identity~ function.

    #+name: test/util/join
    #+begin_src clojure
      (defn join [m-mv]
        (m/bind m-mv identity))
    #+end_src

    Since ~identity~ has type =a → a=
    and bind has type =G a × (a → G b) → G b=,
    applying ~bind~ to a =G (G a)= value and the ~identity~ function
    gives us =a ≡ G b=.
    So join has the desired type =G (G b) → G b=
    (or, alpha-equivalently, =G (G a) → G a=).
*** Kleisli Composition (~>=>~)
    The ~>=>~ function implements left-to-right Kleisli composition.
    That is, ~>=>~ is analogous to Clojure's ~comp~ function, except:
    * Whereas ~comp~ composes "pure" functions with types of form =a → b=,
      ~>=>~ composes "monadic" functions with types of form =a → G b=.
    * Whereas ~comp~ composes functions right-to-left,
      ~>=>~ composes the functions left-to-right.
      That is, the arguments are reversed.
      In this sense, ~>=>~ is analogous to Clojure's ~->~ threading macro
      (but ~>=>~ is a function and operates over functions
      of exactly one argument,
      as oppposed to a macro that operates over forms
      which may consist of many sub-forms).

    #+name: test/util/>=>_
    #+begin_src clojure
      (defn >=> [f g]
        (fn [v]
          (m/bind (f v) g)))
    #+end_src
** Generating Computations
   One major apsect of this testing effort
   is to have the ability to generate random computations
   for use in tests.
   These computations can then be utilized
   to verify certain properties are satisfied.
   In this case, the monad laws.

   To keep things simple, we only generate computations
   of type =G Int=.
   This means that to generate complex computations,
   we will need to generate functions of type =Int → G Int=.

   One key aspect of computation generation
   is the ability to generate composed monadic functions.
   The ~compose-rec~ function takes a composition function
   and a function generator.
   It returns a generator that generates a random tree
   of functions composed by the given composition function.

   #+name: test/computation-gen/compose-rec
   #+begin_src clojure
     (defn compose-rec [compose f-gen]
       (gen/recursive-gen (fn [f-gen]
                            (gen/one-of [f-gen
                                         (gen/let [f f-gen
                                                   g f-gen]
                                           (compose f g))]))
                          f-gen))
   #+end_src

   ~compose-rec~ operates recursively (via ~recursive-gen~),
   but each level does not always generate a function that is a composition
   of two functions.
   This means the subtrees vary in height.
   This helps both to increase the variability of the computions,
   as well as aid in keeping the computations to a reasonable size.

   Although we are mostly interested in composing monadic functions,
   ~compose-rec~ is completely generic with respect to the type
   of composition it performs.
   If ~f-gen~ generates "pure" functions, we can use Clojure's ~comp~
   as the composition functions.
   If ~f-gen~ generates monadic functions, we can use ~>=>~
   (although the arguments to ~comp~ and ~>=>~ are composed
   in a different order, it doesn't matter in our case
   since all functions are homogenous in type).
   We don't even necessarily have to provide an ~f-gen~ that generates functions
   — as long as ~compose~ is able to combine two values generated by ~f-gen~
   (as well its results), we can use ~compose-rec~.

   ~int->m-int~ is a generator that selects from a pool
   of (effectless) base monadic functions:

   #+name: test/computation-gen/int->m-int
   #+begin_src clojure
     (def int->m-int
       (gen/one-of [(gen/return (comp m/return inc'))
                    (gen/return (comp m/return (partial *' 2)))]))
   #+end_src

   Basically, ~int->m-int~ generates a function that either increments
   or doubles the value of the computation to which it is bound.
   Since doubling is exponential with respect to the number
   of times it is composed, we use ~inc′~ and ~*′~ versions
   of ~inc~ and ~*~ (which handles automatic conversion
   to Cloure's ~BigInt~ if necessary)
   in order to avoid integer overflow.

   ~effectful-int->m-int~ generates a tree of composed functions.
   By default, base functions are selected only from ~int->m-int~.
   The optional ~effect-fn~ argument allows an additional source
   of base functions to be mixed in.
   The intention of ~effect-fn~ is to allow a pool
   of effectful functions to be provided for a specific monad.
   (For example, the state monad would provide effectful functions
   that update the computation's state.)
   Functions are composed via Kleisli composition (~>=>~).

   #+name: test/computation-gen/effectful-int->m-int
   #+begin_src clojure
     (defn effectful-int->m-int
       ([]
         (compose-rec >=> int->m-int))
       ([effect-fn]
         (compose-rec >=> (gen/one-of [int->m-int
                                       effect-fn]))))
   #+end_src

   Finally, ~m-int~ allows us to generate computations of type ~G Int~:

   #+name: test/computation-gen/m-int
   #+begin_src clojure
     (defn m-int []
       (gen/frequency [[4 (gen/let [n gen/int]
                            (m/return n))]
                       [1 (gen/let [f  (effectful-int->m-int)
                                    mv (m-int)]
                            (m/bind mv f))]]))
   #+end_src

   ~m-int~ selects from one of two generators:
   * A base generator, which simply wraps a generated integer in ~return~
   * A recursive generator which draws a monadic value
     (via a recursive call to ~m-int~)
     and a function from ~effectful-int->m-int~.
     In this case, the generated result is the drawn monadic value bound
     to the drawn monadic function.

   #+name: test/computation-gen
   #+begin_src clojure :exports none
     <<test/computation-gen/compose-rec>>

     <<test/computation-gen/int->m-int>>

     <<test/computation-gen/effectful-int->m-int>>

     <<test/computation-gen/m-int>>
   #+end_src
** Checking the Monad Laws
   We can now construct =test.check= properties
   to check the monad laws.
   Each monad law will be codified as a function
   that accepts a ~run~ function and one or more generators.
   It will return a property that checks the monad law
   against values generated by the generator.
   Values will be extracted from computations via the provided ~run~ function.

   #+name: test/monad-laws
   #+begin_src clojure
     (defn prop-return-is-left-identity
       ([run x-generator f-generator]
         (prop/for-all [x x-generator
                        f f-generator]
           (= (run (f x))
              (run (m/m-do :bind x' (m/return x)
                           (f x')))))))

     (defn prop-return-is-right-identity
       ([run mv-generator]
         (prop/for-all [mv mv-generator]
           (= (run mv)
              (run (m/m-do :bind x mv
                           (m/return x)))))))

     (defn prop-bind-is-associative
       ([run mv-generator f-generator g-generator]
         (prop/for-all [mv mv-generator
                        f  f-generator
                        g  g-generator]
           (= (run (m/m-do :bind x mv
                           :bind y (f x)
                           (g y)))
              (run (m/m-do :bind y (m/m-do :bind x mv
                                           (f x))
                           (g y)))
              (run (m/m-do :bind x mv
                           (m/m-do :bind y (f x)
                                   (g y))))))))
   #+end_src
*** Checking ~identity-m~
    Checking ~identity-m~ is straight-forward.
    There are no monadic effects to mix in.
    All we need to to is provide an appropriate ~run~ function.

    #+name: test/check-identity-m
    #+begin_src clojure
      (let [run (partial m/run m/identity-m)]
        (defspec check-identity-m-left-identity
          (prop-return-is-left-identity run gen/int (effectful-int->m-int)))
        (defspec check-identity-m-right-identity
          (prop-return-is-right-identity run (m-int)))
        (defspec check-identity-m-associative
          (prop-bind-is-associative run (m-int) (effectful-int->m-int) (effectful-int->m-int))))
    #+end_src
*** Checking ~state-m~
    For ~state-m~, we provide two effectful functions:
    * ~add-state~ :: adds the current computation value
         to the current state value
    * ~mul-state~ :: multiplies the current computation value
         with the current state value

    For ~run~, we also need to extract a final ~[state value]~ pair
    by calling the result of ~m/run~ with an initial state.

    #+name: test/check-state-m
    #+begin_src clojure
      (let [run (fn [mv]
                  (let [mv' (m/run m/state-m mv)]
                    (mv' 1)))
            add-state (fn [v]
                        (m/m-do :bind s (m/get-state)
                                (m/set-state (+' s v))))
            mul-state (fn [v]
                        (m/m-do :bind s (m/get-state)
                                (m/set-state (*' s v))))
            stateful-int->m-int (effectful-int->m-int (gen/one-of [(gen/return add-state)
                                                                   (gen/return mul-state)]))
            stateful-m-int (gen/frequency [[4 (m-int)]
                                           [1 (gen/return (m/get-state))]])]
        (defspec check-state-m-left-identity
          (prop-return-is-left-identity run gen/int stateful-int->m-int))
        (defspec check-state-m-right-identity
          (prop-return-is-right-identity run stateful-m-int))
        (defspec check-state-m-associative
          (prop-bind-is-associative run stateful-m-int stateful-int->m-int stateful-int->m-int)))
    #+end_src
*** Checking ~list-m~
    With ~list-m~, the primary monadic operation is bifurcation.
    That is, "splitting" a single value into multiple values.
    Since =pulley.monad= does not currently provide such an operation,
    we implement a ~choose~ function here.
    ~choose~ accepts any number of monad computations
    and combines them (via ~join~) into a single computation.
    ~choose~ is the "monad plus" operator, specialized to the list monad.

    ~choiceful-int->m-int~ generates a function
    that uses ~choose~ to combine the results
    of applying the provided value ~v~
    to two recursively generated functions.
    Because each invocation of ~choose~ effectively doubles the number
    of values produced by the computation,
    we must take care to limit the use of ~choose~.
    The ~recurse~ local is bound to a generator
    that allows for recursive application of ~choose~
    but in a way that makes it fairly improbable.

    ~choiceful-m-int~ serves a similar purpose,
    but for initial monadic values.

    Note that in cases where we manually build recursive generators,
    it is necessary to delay the recursive call
    by introducing a bogus ~gen/let~ binding.
    Otherwise, a stack overflow will occur.

    #+name: test/check-list-m
    #+begin_src clojure
      (let [run (partial m/run m/list-m)
            choose (comp join m/lift|concrete->generic list)
            choiceful-int->m-int (fn choiceful-int->m-int []
                                   (let [recurse (gen/let [_ (gen/return nil)]
                                                   (effectful-int->m-int (choiceful-int->m-int)))
                                         f-gen (gen/frequency [[49 (effectful-int->m-int)]
                                                               [1 recurse]])]
                                     (gen/let [_ (gen/return nil)
                                               f f-gen
                                               g f-gen]
                                       (fn [v]
                                         (choose (f v)
                                                 (g v))))))
            choiceful-m-int (fn choiceful-m-int []
                              (gen/frequency [[3 (m-int)]
                                              [1 (gen/let [_ (gen/return nil)
                                                           mv1 (choiceful-m-int)
                                                           mv2 (choiceful-m-int)]
                                                   (choose mv1 mv2))]
                                              [1 (gen/let [_ (gen/return nil)
                                                           mv (choiceful-m-int)
                                                           f (effectful-int->m-int)]
                                                   (m/bind mv f))]]))]
        (defspec check-list-m-left-identity
          (prop-return-is-left-identity run gen/int (effectful-int->m-int (choiceful-int->m-int))))
        (defspec check-list-m-right-identity
          (prop-return-is-right-identity run (choiceful-m-int)))
        (defspec check-list-m-associative
          (prop-bind-is-associative run (choiceful-m-int) (effectful-int->m-int (choiceful-int->m-int)) (effectful-int->m-int (choiceful-int->m-int)))))
    #+end_src
* Future Work
  * We use maps of operations
    to implement a form of Haskell's notion of a typeclass.
    There may be other cases that could benefit
    from a generic implementation of a typeclass,
    suggesting a library abstracting typeclasses.
  * The relationship between the Generic monad presented here
    and the Free monad should be explored further.
    On the surface, they appear to express similar ideas — generic computations.
    However, they seem to take slightly different approaches.
    It may be that the Free monad is a better abstraction.
    The Generic monad is capable of being used with /any/ monad.
    Since the Free monad turns any functor into a monad,
    and monads are a subclass of functors,
    the same would appear to hold for the Free monad as well.
  * It will be interesting to see what uses
    for the Generic monad can be found.
    Potential applications include:
    * Generic code transformation.
      By parameterizing operations via the Generic monad,
      a single transform can be used to achieve a variety of effects
      (e.g., continuations, tracing / debugging, cooperative multitasking).
    * Composable "interpretters", which might be implemented as follows:
      * Code is written against generic operations
        (operations whose implementation will be provided
        in the operations map).
      * Various "interpretters" provide implementations for those operations.
      * Interpretters can write against operations provided
        by other interpretters.
      * Interpretters can be combined to implement [[http://degoes.net/articles/modern-fp-part-2][onion architectures]].
* Source Code
** =monad.clj=
   #+begin_src clojure :noweb yes :mkdirp yes :tangle src/clj/com/positronic_solutions/pulley/monad.clj
     ;; Copyright 2016-2017 Positronic Solutions, LLC.
     ;;
     ;; This file is part of pulley.monad.
     ;;
     ;; pulley.monad is free software: you can redistribute it and/or modify
     ;; it under the terms of the GNU Lesser General Public License as published by
     ;; the Free Software Foundation, either version 3 of the License, or
     ;; (at your option) any later version.
     ;;
     ;; pulley.monad is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.
     ;;
     ;; You should have received a copy of the GNU Lesser General Public License
     ;; along with pulley.monad.  If not, see <http://www.gnu.org/licenses/>.

     <<pulley.monad::ns>>

     <<run>>

     <<return>>

     <<bind>>

     <<value>>

     <<when-run*>>

     <<when-run>>

     <<>>=>>

     <<>>_>>

     <<m-let>>

     <<m-do>>

     <<get-ops>>

     <<bind-ops>>

     <<let-ops>>

     <<op-fn*>>

     <<op-fn>>

     <<defop>>

     <<identity-m>>

     <<list-m>>

     <<state-m>>

     <<get-state>>

     <<set-state>>
   #+end_src
** Tests
*** =test/monad_laws.clj=
    #+begin_src clojure :noweb yes :mkdirp yes :tangle test/check/com/positronic_solutions/pulley/monad/test/monad_laws.clj
      <<test/monad-laws/ns>>

      <<test/util/join>>

      <<test/util/>=>_>>

      <<test/monad-laws>>

      <<test/computation-gen>>

      <<test/check-identity-m>>

      <<test/check-state-m>>

      <<test/check-list-m>>
    #+end_src
